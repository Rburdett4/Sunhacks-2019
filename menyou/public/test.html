<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1, maximum-scale=1,user-scalable=no"
    />

    <title>FeatureLayerView - query statistics by geometry - 4.12</title>

    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.12/esri/themes/light/main.css"
    />
    <link
      rel="stylesheet"
      href="https://js.arcgis.com/4.12/dijit/themes/claro/claro.css"
    />

    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }

      #chartPanel {
        background: #fff;
        font: "Avenir Next W00";
        line-height: 1.5em;
        overflow: auto;
        padding: 10px;
        width: 580px;
        height: 300px;
      }

      .chart {
        height: 280px;
      }
    </style>

    <!-- Load the Chart.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.4.0/Chart.min.js"></script>
    <script src="https://js.arcgis.com/4.12/"></script>

    <script>
      require([
        "esri/widgets/Sketch/SketchViewModel",
        "esri/geometry/Polyline",
        "esri/geometry/Point",
        "esri/Graphic",
        "esri/Map",
        "esri/views/MapView",
        "esri/layers/FeatureLayer",
        "esri/layers/GraphicsLayer",
        "esri/geometry/geometryEngine",
        "esri/widgets/Expand",
        "esri/widgets/Legend",
        "esri/widgets/Search",
        "esri/core/watchUtils",
        "esri/widgets/Search"
      ], function(
        SketchViewModel,
        Polyline,
        Point,
        Graphic,
        Map,
        MapView,
        FeatureLayer,
        GraphicsLayer,
        geometryEngine,
        Expand,
        Legend,
        Search,
        watchUtils
      ) {
        // App 'globals'
        let sketchViewModel, featureLayerView, pausableWatchHandle, chartExpand;

        let centerGraphic,
          edgeGraphic,
          polylineGraphic,
          bufferGraphic,
          centerGeometryAtStart,
          labelGraphic;

        const unit = "kilometers";

        // Create layers
        const graphicsLayer = new GraphicsLayer();
        const graphicsLayer2 = new GraphicsLayer();

        const featureLayer = new FeatureLayer({
          portalItem: {
            id: "83c37666a059480bb8a7cb73f449ff52"
          },
          outFields: ["*"]
        });

        // Create map
        const map = new Map({
          basemap: "dark-gray",
          layers: [featureLayer, graphicsLayer2, graphicsLayer]
        });

        // Create view
        const view = new MapView({
          container: "viewDiv",
          map: map,
          zoom: 14,
          center: [-111.9400, 33.4255],
          constraints: {
            maxScale: 0,
            minScale: 300000
          }
        });

        // Set up statistics definition for client-side query
        // Total popultion of age groups by gender in census tracts
        const statDefinitions = [
          "FEM85C10",

        ].map(function(fieldName) {
          return {
            onStatisticField: fieldName,
            outStatisticFieldName: fieldName + "_TOTAL",
            statisticType: "sum"
          };
        });

        // Update UI
        setUpAppUI();
        setUpSketch();

        function setUpAppUI() {
          // When layer is loaded, create a watcher to trigger drawing of the buffer polygon

          view.whenLayerView(featureLayer).then(function(layerView) {
            featureLayerView = layerView;

            pausableWatchHandle = watchUtils.pausable(
              layerView,
              "updating",
              function(val) {
                if (!val) {
                  drawBufferPolygon();
                }
              }
            );

          });

          view.when(function() {
            // Display the chart in an Expand widget

            const search = new Search({
              view: view,
              resultGraphicEnabled: false,
              popupEnabled: false
            });
            view.ui.add(search, "top-right");
            view.zoom(14)

            // Resume drawBufferPolygon() function; user searched for a new location
            // Must update the buffer polygon and re-run the stats query
            search.on("search-complete", function() {
              pausableWatchHandle.resume();
            });



          });

        }

        /*****************************************************************
         * Create SketchViewModel and wire up event listeners
         *****************************************************************/
        function setUpSketch() {
          sketchViewModel = new SketchViewModel({
            view: view,
            layer: graphicsLayer
          });

          // Listen to SketchViewModel's update event so that population pyramid chart
          // is updated as the graphics are updated
          // sketchViewModel.on("update", onMove)
        }


        /*********************************************************************
         * Edge or center point is being updated. Recalculate the buffer with
         * updated geometry information.
         *********************************************************************/
        function calculateBuffer(vertices) {
          // Update the geometry of the polyline based on location of edge and center points
          polylineGraphic.geometry = new Polyline({
            paths: vertices,
            spatialReference: view.spatialReference
          });

          // Recalculate the polyline length and buffer polygon
          const length = geometryEngine.geodesicLength(
            polylineGraphic.geometry,
            unit
          );
          const buffer = geometryEngine.geodesicBuffer(
            centerGraphic.geometry,
            length,
            unit
          );

          // Update the buffer polygon
          bufferGraphic.geometry = buffer;

          // Query female and male age groups of the census tracts that intersect
          // the buffer polygon on the client
          queryLayerViewAgeStats(buffer).then(function(newData) {
            // Create a population pyramid chart from the returned result
            // TODO DO SOMETHING AWESOME
          });

        }

        /*********************************************************************
         * Spatial query the census tracts feature layer view for statistics
         * using the updated buffer polygon.
         *********************************************************************/
        function queryLayerViewAgeStats(buffer) {
          // Data storage for the chart
          let femaleAgeData = [],
            maleAgeData = [];

          // Client-side spatial query:
          // Get a sum of age groups for census tracts that intersect the polygon buffer
          const query = featureLayerView.layer.createQuery();
          query.outStatistics = statDefinitions;
          query.geometry = buffer;

          // Query the features on the client using FeatureLayerView.queryFeatures
          return featureLayerView
            .queryFeatures(query)
            .then(function(results) {
              // Statistics query returns a feature with 'stats' as attributes
              const attributes = results.features[0].attributes;
              // Loop through attributes and save the values for use in the population pyramid.
              for (var key in attributes) {
                console.log(key)
                console.log(attributes[key])
              }
              // Return information, seperated by gender
              return [];
            })
            .catch(function(error) {
              console.log(error);
            });
        }

        /***************************************************
         * Draw the buffer polygon when application loads or
         * when user searches for a new location
         **************************************************/
        function drawBufferPolygon() {
          // When pause() is called on the watch handle, the callback represented by the
          // watch is no longer invoked, but is still available for later use
          // this watch handle will be resumed when user searches for a new location
          pausableWatchHandle.pause();

          // Initial location for the center, edge and polylines on the view
          const viewCenter = view.center.clone();
          const centerScreenPoint = view.toScreen(viewCenter);
          const centerPoint = view.toMap({
            x: centerScreenPoint.x,
            y: centerScreenPoint.y
          });
          const edgePoint = view.toMap({
            x: centerScreenPoint.x,
            y: centerScreenPoint.y-400
          });

          // Store updated vertices
          const vertices = [
            [centerPoint.x, centerPoint.y],
            [edgePoint.x, edgePoint.y]
          ];

          // Create center, edge, polyline and buffer graphics for the first time
          if (!centerGraphic) {
            const polyline = new Polyline({
              paths: vertices,
              spatialReference: view.spatialReference
            });

            // get the length of the initial polyline and create buffer
            const length = geometryEngine.geodesicLength(polyline, unit);
            const buffer = geometryEngine.geodesicBuffer(
              centerPoint,
              length,
              unit
            );

            // Create the graphics representing the line and buffer
            const pointSymbol = {
              type: "simple-marker",
              style: "circle",
              size: 10,
              color: [255, 0, 0, 0.5]
            };
            centerGraphic = new Graphic({
              geometry: centerPoint,
              symbol: pointSymbol,
              attributes: {
                center: "center"
              }
            });

            edgeGraphic = new Graphic({
              geometry: edgePoint,
              symbol: pointSymbol,
              attributes: {
                edge: "edge"
              }
            });

            polylineGraphic = new Graphic({
              geometry: polyline,
              symbol: {
                type: "simple-line",
                color: [254, 254, 254, 1],
                width: 2.5
              }
            });

            bufferGraphic = new Graphic({
              geometry: buffer,
              symbol: {
                type: "simple-fill",
                color: [150, 150, 150, 0.2],
                outline: {
                  color: "#FFEB00",
                  width: 2
                }
              }
            });


            // Add graphics to layer
            graphicsLayer.addMany([centerGraphic, edgeGraphic]);
            // once center and edge point graphics are added to the layer,
            // call sketch's update method pass in the graphics so that users
            // can just drag these graphics to adjust the buffer
            setTimeout(function() {
              sketchViewModel.update([edgeGraphic, centerGraphic], {
                tool: "move"
              });
            }, 1000);

            graphicsLayer2.addMany([
              bufferGraphic,
              polylineGraphic,
            ]);
          }
          // Move the center and edge graphics to the new location returned from search
          else {
            centerGraphic.geometry = centerPoint;
            edgeGraphic.geometry = edgePoint;
          }
          // Query features that intersect the buffer
          calculateBuffer(vertices);
        }


      });
    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
    <div id="chartPanel"><canvas id="chart" class="chart"></canvas></div>
  </body>
</html>
